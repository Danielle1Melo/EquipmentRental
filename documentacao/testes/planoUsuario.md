# Plano de Teste para Model de Usuario (Sprint V)

| Funcionalidade                   | Comportamento Esperado                                                                 | Verificações                                                      | Critérios de Aceite                                                                                           |
|----------------------------------|----------------------------------------------------------------------------------------|-------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------|
| Cadastro válido de usuário       | Um usuário com todos os dados válidos deve ser salvo corretamente                      | Criar um usuário com todos os campos preenchidos                 | O usuário é salvo e os dados (exceto senha) podem ser consultados com precisão                               |
| Email duplicado                  | O sistema não deve permitir dois usuários com o mesmo email                            | Tentar cadastrar dois usuários com o mesmo email                 | A operação falha com erro de chave duplicada referente ao campo `email`                                      |
| Telefone duplicado               | O sistema não deve permitir dois usuários com o mesmo telefone                         | Tentar cadastrar dois usuários com o mesmo telefone              | A operação falha com erro de chave duplicada referente ao campo `telefone`                                   |
| CPF duplicado                    | O sistema não deve permitir dois usuários com o mesmo CPF                              | Tentar cadastrar dois usuários com o mesmo CPF                   | A operação falha com erro de chave duplicada referente ao campo `CPF`                                        |
| Isolamento entre testes          | Cada teste deve rodar com um banco limpo                                               | Verificar que `deleteMany` é chamado após cada teste             | Nenhum teste interfere no estado de outro, garantindo independência                                          |
| Conexão e desconexão do banco    | O banco em memória deve ser iniciado antes e desligado após os testes                 | Usar `beforeAll` para iniciar e `afterAll` para encerrar         | Os testes se conectam corretamente ao banco e liberam recursos no fim                                        |
| Índices do modelo                | Os índices devem ser criados corretamente antes da execução dos testes                 | Verificar que `createIndexes()` é chamado no modelo              | O Mongo cria os índices exigidos, como os de unicidade (`email`, `telefone`, `CPF`)                          |


# Plano de Teste para Controller Usuario (Sprint V)

| Funcionalidade                  | Comportamento Esperado                                                                 | Verificações                                                                 | Critérios de Aceite                                                                                  |
|---------------------------------|----------------------------------------------------------------------------------------|------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------|
| Listagem geral de usuários      | Deve retornar todos os usuários cadastrados                                            | Chamar `listar` sem `params` ou `query`                                     | A resposta deve conter status `200` e um array com todos os usuários                                  |
| Listagem por ID                 | Deve retornar um único usuário quando passado o ID                                     | Chamar `listar` com `req.params.id`                                         | A resposta deve conter status `200` e o objeto do usuário correspondente                              |
| Listagem por query              | Deve retornar o(s) usuário(s) filtrado(s) por campo (ex: email)                         | Chamar `listar` com `req.query.email`                                       | A resposta deve conter status `200` e o(s) usuário(s) filtrado(s)                                     |
| Cadastro de usuário             | Deve permitir cadastrar um novo usuário com dados válidos                              | Chamar `cadastrarUsuario` com `req.body` preenchido                         | A resposta deve conter status `201`, um objeto com os dados e uma mensagem de sucesso                 |
| Atualização de usuário          | Deve permitir atualizar os dados de um usuário existente pelo ID                       | Chamar `updateUsuario` com `req.params.id` e novos dados em `req.body`      | A resposta deve conter status `200`, os dados atualizados e uma mensagem de sucesso                   |
| Erro ao atualizar sem ID        | Não deve permitir atualizar um usuário se o ID não for informado                       | Chamar `updateUsuario` sem definir `req.params`                             | A função deve lançar um erro e não deve retornar status `200`                                         |
| Inicialização dos mocks         | A cada teste os mocks devem ser limpos e o controller reinicializado                   | Verificar uso de `jest.clearAllMocks()` e recriação de instâncias           | Cada teste deve ser isolado e não dependente de dados ou estado de outros                             |

# Plano de Teste para Service Usuario(Sprint V)

| Funcionalidade                       | Comportamento Esperado                                                                              | Verificações                                                                 | Critérios de Aceite                                                                                      |
|-------------------------------------|-------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------|
| Listagem geral de usuários          | Deve retornar todos os usuários cadastrados                                                           | Chamar `listar` sem parâmetros                                               | A função retorna um array com todos os usuários                                                           |
| Listagem por ID                     | Deve retornar um usuário específico baseado no ID                                                     | Chamar `listar` com `req.params.id`                                          | A função retorna o usuário correspondente                                                                 |
| Listagem com filtros (query)        | Deve filtrar usuários com base em parâmetros (ex: nome)                                               | Chamar `listar` com `req.query`                                              | A função retorna apenas os usuários compatíveis com os filtros                                            |
| Cadastro válido                     | Deve cadastrar um novo usuário se CPF, e-mail e telefone forem únicos                                 | Chamar `cadastrarUsuario` com dados válidos                                  | O usuário é cadastrado e retornado com um ID                                                              |
| Erro de CPF duplicado               | Deve lançar erro se o CPF já estiver em uso                                                           | Simular `buscarPorCpf` retornando erro `CustomError`                         | A função deve lançar `CustomError` com mensagem de conflito de CPF                                        |
| Erro de e-mail duplicado            | Deve lançar erro se o e-mail já estiver em uso                                                        | Simular `buscarPorEmail` retornando erro `CustomError`                       | A função deve lançar `CustomError` com mensagem de conflito de E-mail                                     |
| Erro de telefone duplicado          | Deve lançar erro se o telefone já estiver em uso                                                      | Simular `buscarPorTelefone` retornando erro `CustomError`                    | A função deve lançar `CustomError` com mensagem de conflito de Telefone                                   |
| Atualização completa de usuário     | Deve permitir atualizar todos os campos permitidos com dados válidos                                  | Chamar `updateUsuario` com `req.params.id` e `req.body` completo             | A função deve retornar os dados atualizados corretamente                                                  |
| Atualização parcial de usuário      | Deve permitir atualizar somente alguns campos de um usuário                                           | Chamar `updateUsuario` com ID e dados parciais                               | A função retorna os dados modificados preservando os anteriores                                           |
| Erro ao atualizar e-mail duplicado | Deve lançar erro se o novo e-mail já estiver associado a outro usuário                                | Simular `buscarPorEmail` retornando erro                                     | A função lança `CustomError` com mensagem de conflito de E-mail                                           |
| Erro ao atualizar telefone usado    | Deve lançar erro se o novo telefone já estiver associado a outro usuário                              | Simular `buscarPorTelefone` retornando erro                                  | A função lança `CustomError` com mensagem de conflito de Telefone                                         |
| Limpeza de mocks                    | Após cada teste os mocks devem ser limpos                                                             | Verificar uso de `jest.clearAllMocks()`                                      | Os testes são isolados e não compartilham estado                                                           |

# Plano de Teste para Repository Usuario (Sprint V)

| Funcionalidade                          | Comportamento Esperado                                                                 | Verificações                                                                          | Critérios de Aceite                                                                                         |
|----------------------------------------|----------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------|
| Buscar por ID                          | Deve retornar um usuário existente a partir do ID                                      | Chamar `listar` com `req.params.id`                                                  | A função retorna o usuário correspondente                                                                 |
| Não encontrar por ID                   | Deve retornar `null` se o usuário com o ID não existir                                 | Chamar `listar` com um ID inexistente                                                | A função retorna `null`                                                                                    |
| Listagem paginada                      | Deve retornar todos os usuários com metadados de paginação                             | Chamar `listar` sem parâmetros                                                       | A função retorna array de usuários e dados como `totalDocs`, `page`, `limit`, etc.                         |
| Atualizar usuário                      | Deve atualizar um usuário existente com sucesso                                        | Chamar `updateUsuario` com ID e dados válidos                                        | A função retorna o objeto atualizado                                                                       |
| Erro ao atualizar (e-mail persistente) | Deve lançar erro se tentar atualizar para um e-mail já existente                       | Simular `findByIdAndUpdate` retornando `null`                                        | A função lança `CustomError` com mensagem de "Recurso não encontrado"                                      |
| Cadastro de usuário                    | Deve cadastrar um novo usuário                                                         | Chamar `cadastrarUsuario` com dados válidos                                          | A função retorna o objeto criado com sucesso                                                               |
| Verificação de e-mail único            | Deve retornar `undefined` se não existir e-mail duplicado                              | Chamar `buscarPorEmail` com e-mail inexistente                                       | A função resolve sem erro                                                                                  |
| Verificação de telefone único          | Deve retornar `undefined` se não existir telefone duplicado                            | Chamar `buscarPorTelefone` com telefone inexistente                                  | A função resolve sem erro                                                                                  |
| Buscar por CPF                         | Deve retornar `undefined` se o CPF não estiver em uso                                  | Chamar `buscarPorCpf` com CPF inexistente                                            | A função resolve como `undefined`                                                                          |
| Buscar por ID (direto)                 | Deve retornar o usuário existente a partir de um ID                                    | Chamar `buscarPorId`                                                                 | A função retorna o objeto do usuário                                                                       |
| Erro ao buscar por e-mail existente    | Deve lançar `CustomError` se o e-mail já estiver em uso                                | Simular `findOne` retornando objeto                                                  | A função lança erro de conflito                                                                            |
| Erro ao buscar por telefone existente  | Deve lançar `CustomError` se o telefone já estiver em uso                              | Simular `findOne` retornando objeto                                                  | A função lança erro de conflito                                                                            |
| Erro ao buscar por ID inexistente      | Deve lançar `CustomError` se o usuário com o ID não existir                            | Simular `findById` retornando `null`                                                 | A função lança erro de recurso não encontrado                                                              |
| Erro ao buscar por CPF existente       | Deve lançar `CustomError` se o CPF já estiver em uso                                   | Simular `findOne` retornando objeto                                                  | A função lança erro de conflito                                                                            |
| Isolamento entre testes                | Cada teste deve rodar com dados limpos e mocks reiniciados                             | Verificar uso de `jest.clearAllMocks()`                                              | Nenhum teste interfere no outro                                                                            |

# Plano de Teste para FilterBuilder Usuario (Sprint V)

| Funcionalidade                  | Comportamento Esperado                                                                      | Verificações                                                             | Critérios de Aceite                                                                 |
|---------------------------------|---------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|--------------------------------------------------------------------------------------|
| Filtro por nome                 | Deve adicionar uma condição de filtro pelo nome                                             | Chamar `comNome('Luan')` seguido de `build()`                            | O resultado contém a chave `nome` com regex insensível a maiúsculas                 |
| Nome vazio ou indefinido        | Não deve adicionar filtro se o nome for `''` ou `undefined`                                | Chamar `comNome('')` e `comNome(undefined)`                              | O resultado **não** possui a chave `nome`                                           |
| Filtro por email                | Deve adicionar uma condição de filtro pelo email                                            | Chamar `comEmail('meu@gmail.com')` seguido de `build()`                  | O resultado contém a chave `email` com regex insensível a maiúsculas                |
| Email vazio ou indefinido       | Não deve adicionar filtro se o email for `''` ou `undefined`                               | Chamar `comEmail('')` e `comEmail(undefined)`                            | O resultado **não** possui a chave `email`                                          |
| Filtro por status (ativo)       | Deve adicionar condição `{ $eq: "ativo" }` ao status                                        | Chamar `comStatus('ativo')` seguido de `build()`                         | O resultado possui a chave `status` com valor `{ $eq: "ativo" }`                    |
| Filtro por status (inativo)     | Deve adicionar condição `{ $eq: "inativo" }` ao status                                      | Chamar `comStatus('inativo')` seguido de `build()`                       | O resultado possui a chave `status` com valor `{ $eq: "inativo" }`                  |
| Status vazio ou indefinido      | Não deve adicionar filtro se o status for `''` ou `undefined`                              | Chamar `comStatus('')` e `comStatus(undefined)`                          | O resultado **não** possui a chave `status`                                         |
| Filtro por tipoUsuario          | Deve adicionar condição `{ $eq: "usuario" }` ao tipo de usuário                            | Chamar `comTipoUsuario('usuario')` seguido de `build()`                  | O resultado possui a chave `tipoUsuario` com valor `{ $eq: "usuario" }`             |
| tipoUsuario vazio ou indefinido | Não deve adicionar filtro se o tipo de usuário for `''` ou `undefined`                     | Chamar `comTipoUsuario('')` e `comTipoUsuario(undefined)`                | O resultado **não** possui a chave `tipoUsuario`                                    |
| Reset e isolamento              | Os filtros devem ser reinicializados entre os testes para não acumularem configurações      | Verificar uso de `beforeEach` e `jest.clearAllMocks()`                   | Cada chamada do builder é independente e não herda filtros anteriores               |

# Plano de Teste para Schema Usuario (Sprint V)

| Funcionalidade                     | Comportamento Esperado                                                                                     | Verificações                                                                       | Critérios de Aceite                                                                                     |
|------------------------------------|------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------|
| Validação completa (`parse`)       | Deve validar todos os campos com dados válidos                                                             | Usar `UsuarioSchema.parse()` com mock completo                                     | Todos os campos são aceitos sem exceções                                                                |
| Nome - formato inválido            | Deve lançar erro se nome contiver números, caracteres especiais ou espaços duplicados                      | Usar `.parseAsync({nome: "Nome  123"})`                                           | Retorna erro de validação para formato incorreto                                                       |
| Nome - tipo incorreto              | Deve lançar erro se nome não for do tipo string                                                            | Usar `.parseAsync({nome: 123})`                                                   | Retorna erro dizendo que o nome deve ser string                                                        |
| Nome - campo vazio                 | Deve lançar erro se nome estiver vazio                                                                     | Usar `.parseAsync({nome: ""})`                                                    | Retorna erro de campo obrigatório                                                                      |
| Email - válido                     | Deve aceitar e-mail válido                                                                                 | Usar `.parse({email: "email@gmail.com"})`                                         | Retorna os dados normalmente                                                                           |
| Email - formato inválido          | Deve lançar erro para e-mail sem `@` ou domínio                                                            | Usar `.parseAsync({email: "emailInvalido"})`                                      | Retorna erro de formato de email                                                                       |
| Email - campo vazio                | Deve lançar erro se o campo de e-mail estiver vazio                                                        | Usar `.parseAsync({email: ""})`                                                   | Retorna erro de campo obrigatório                                                                      |
| Email - tipo incorreto             | Deve lançar erro se email não for string                                                                   | Usar `.parseAsync({email: 123})`                                                  | Retorna erro de tipo                                                                                   |
| Telefone - válido                  | Deve aceitar formato correto de telefone                                                                   | Usar `.parse({telefone: "(69) 9999-9999"})`                                       | Retorna os dados normalmente                                                                           |
| Telefone - formato inválido        | Deve lançar erro para formato de telefone fora do padrão                                                   | Usar `.parseAsync({telefone: "telefoneInvalido"})`                                | Retorna erro de formato esperado                                                                      |
| Telefone - tipo incorreto          | Deve lançar erro se telefone não for string                                                                | Usar `.parseAsync({telefone: 123456789})`                                         | Retorna erro de tipo                                                                                   |
| Senha - válida                     | Deve aceitar senha forte                                                                                   | Usar `.parse({senha: "Senha123@"})`                                               | Retorna os dados normalmente                                                                           |
| Senha - fraca ou incompleta        | Deve lançar erro para senha que não siga os critérios de segurança                                         | Usar `.parseAsync({senha: "senha"})` ou sem caractere especial                     | Retorna erro de formato ou tamanho mínimo                                                              |
| Senha - tipo incorreto             | Deve lançar erro se senha não for string                                                                   | Usar `.parseAsync({senha: 123})`                                                  | Retorna erro de tipo                                                                                   |
| Data de nascimento - válida        | Deve aceitar datas com mais de 18 anos                                                                     | Usar `.parse({dataNascimento: "2000-01-01"})`                                     | Retorna os dados normalmente                                                                           |
| Data nascimento - formato inválido | Deve lançar erro para data fora do padrão ISO                                                              | Usar `.parseAsync({dataNascimento: "20000101"})`                                  | Retorna erro de formato                                                                                |
| Data nascimento - menor de idade   | Deve lançar erro para usuários com menos de 18 anos                                                        | Usar `.parseAsync({dataNascimento: "2015-01-01"})`                                | Retorna erro sobre idade mínima                                                                       |
| CPF - válido                       | Deve aceitar um CPF com 11 dígitos numéricos e válido                                                      | Usar `.parse({CPF: "09272083001"})`                                               | Retorna os dados normalmente                                                                           |
| CPF - inválido ou repetido         | Deve lançar erro se CPF for inválido ou igual a sequências como `000...`                                   | Usar `.parseAsync({CPF: "00000000000"})`                                          | Retorna erro de CPF inválido                                                                          |
| CPF - tipo incorreto               | Deve lançar erro se CPF não for string                                                                     | Usar `.parseAsync({CPF: 123456789})`                                              | Retorna erro de tipo                                                                                   |
| Status - "ativo" ou "inativo"      | Deve aceitar status apenas como "ativo" ou "inativo"                                                       | Usar `.parse({status: "ativo"})` ou `.parse({status: "inativo"})`                 | Retorna os dados normalmente                                                                           |
| Status - inválido ou vazio         | Deve lançar erro se status for qualquer outro valor ou estiver vazio                                       | Usar `.parseAsync({status: ""})`                                                  | Retorna erro indicando valores aceitos                                                                |
| Nota média - válida                | Deve aceitar notas entre 0 e 10                                                                            | Usar `.parse({notaMedia: 10})`                                                    | Retorna os dados normalmente                                                                           |
| Nota média - abaixo de 0 ou acima de 10 | Deve lançar erro se nota for < 0 ou > 10                                                            | Usar `.parseAsync({notaMedia: -1})` ou `.parseAsync({notaMedia: 11})`            | Retorna erro de valor fora da faixa                                                                   |
| tipoUsuario - válido               | Deve aceitar valores "usuario" ou "admin"                                                                  | Usar `.parse({tipoUsuario: "usuario"})`                                           | Retorna os dados normalmente                                                                           |
| tipoUsuario - inválido             | Deve lançar erro se o tipo não for "usuario" ou "admin"                                                    | Usar `.parseAsync({tipoUsuario: "outro"})`                                        | Retorna erro de valor inválido                                                                        |
| fotoUsuario - válida               | Deve aceitar uma URL válida                                                                                | Usar `.parse({fotoUsuario: "https://..."})`                                       | Retorna os dados normalmente                                                                           |
| fotoUsuario - inválida             | Deve lançar erro para URLs inválidas ou tipos incorretos                                                   | Usar `.parseAsync({fotoUsuario: "texto aleatório"})` ou `.parseAsync({fotoUsuario: 123})` | Retorna erro de URL inválida ou tipo incorreto                                           |

# Plano de Teste para QuerySchema Usuario (Sprint V)

| Funcionalidade               | Comportamento Esperado                                                                          | Verificações                                                                    | Critérios de Aceite                                                                                 |
|------------------------------|-------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------|
| Nome - válido                | Deve aceitar nome não vazio e sem apenas espaços                                                | Usar `.parse({ nome: "Usuario" })`                                              | Retorna objeto com o nome                                                                           |
| Nome - inválido              | Deve lançar erro se nome for apenas espaços                                                     | Usar `.parseAsync({ nome: " " })`                                               | Retorna mensagem "Nome não pode ser vazio ou apenas espaços"                                       |
| Email - válido               | Deve aceitar e-mail em formato válido                                                           | Usar `.parse({ email: "usuario@gmail.com" })`                                   | Retorna objeto com o e-mail                                                                         |
| Email - inválido             | Deve lançar erro para e-mail em formato incorreto                                               | Usar `.parseAsync({ email: "email-invalido" })`                                 | Retorna mensagem "Formato de email inválido"                                                        |
| Página - válida              | Deve converter valor string numérico em inteiro                                                 | Usar `.parse({ page: "1" })`                                                    | Retorna `{ page: 1 }`                                                                               |
| Página - inválida            | Deve lançar erro para valores não numéricos ou negativos                                        | Usar `.parseAsync({ page: "abc" })`                                             | Retorna mensagem "Page deve ser um número inteiro maior que 0"                                     |
| Página - valor padrão        | Deve usar `1` como valor padrão se não for fornecido                                            | Usar `.parse({ page: "" })`                                                     | Retorna `{ page: 1 }`                                                                               |
| Limite - válido              | Deve converter string numérica em inteiro dentro do intervalo permitido                        | Usar `.parse({ limite: "10" })`                                                 | Retorna `{ limite: 10 }`                                                                            |
| Limite - maior que 100       | Deve lançar erro se valor for superior a 100                                                    | Usar `.parseAsync({ limite: "101" })`                                           | Retorna mensagem "Limite deve ser um número inteiro entre 1 e 100"                                 |
| Limite - menor que 1         | Deve lançar erro se valor for inferior a 1                                                      | Usar `.parseAsync({ limite: "-101" })`                                          | Retorna mensagem "Limite deve ser um número inteiro entre 1 e 100"                                 |
| Limite - não numérico        | Deve lançar erro se valor não for um número                                                     | Usar `.parseAsync({ limite: "abc" })`                                           | Retorna mensagem "Limite deve ser um número inteiro entre 1 e 100"                                 |
| Limite - valor padrão        | Deve usar `10` como valor padrão se `limite` não for fornecido                                  | Usar `.parse({})`                                                               | Retorna `{ limite: 10 }`                                                                            |
